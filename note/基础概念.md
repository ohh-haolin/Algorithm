# 老生常谈

## 时间复杂度

众所周知，计算机中我们常常使用大$O$表示法来描述一个算法的运算数量（又称复杂度）。大$O$表示法侧重于描述当数据量较大时算法的运行速度，这非常符合算法的运行工况。它的表达式关心的是函数最高的幂次（或称阶数），想一想似乎确实很有道理。看一个例子：

- 输入$N$个数，找出所有的$x$和$y$满足两数之和为$W$并输出

让我瞎搞个思路：把$\{ A \}$排序，从前往后对每个$A_i$用一次用二分查找是否存在$W-A_i$

请问复杂度是多少呢？让我们一步一步分解



1. 输入：$N$次操作

2. 排序：$N\log N$次

3. 从前往后遍历：$N$次

   每次使用二分查找：$\log N$次

   合起来：$N\log N$次

4. 输出：$N$次操作



来看这些问题：

1. 第一步和第四步是算法的组成么？

   不是

2. 该算法的复杂度是多少？

   $Nlog N + Nlog N = 2NlogN$

3. 为什么要写个系数？

   尽管你的确可以不写系数，有可能有很多人吹捧，但请你思考，大$O$表示的仅仅是数字么？

   如果仅仅是$N \log N$你真的能够明白这个算法的过程和特性么？

   数据量是否真的足够大以至于你可以忽略掉这个系数了么？

   


> 不知庐山真面目木，只缘身在此山中。
>
> 虽然听起来是个小学生作文引用的话，但请你们不要被这些表面数字所困扰住。
>
> 这道题非常的简单，如果我们把它放到递归中，你还能一眼看出来么？



## 状态

什么是状态？这是一个非常模糊的问题，我们用两个同义词来稍加解释：属性，特性。

想想，生活中有哪些常见的“状态”。

- 时空位置
- 价格
- 距离
- ...

题目中经常有

- 是否用过，是否走过
- 父节点，子节点
- 左端点，右端点
- 当前的代价
- ...



那么，对于我们目前要掌握的题目，其实都可以抽象成这么一个简单的概念：
题目给定了一个初始状态，给定了一个终止状态，请找出中间的代价/最优解等等



如何解决这样的题目呢？

先找到各式各样的多种状态，然后利用你找到的这些状态组合起来，形成状态转移方程，从题目指定的状态开始一直转移到终止的状态，并检查一些题目要求维护的信息。过程中如果遇见不合法的情况，则还原到上一步。

> 是不是感觉很熟悉呢



来看几个例题和几个数据结构



