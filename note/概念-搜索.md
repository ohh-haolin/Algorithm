# 老生常谈

## 时间复杂度

众所周知，计算机中我们常常使用大$O$表示法来描述一个算法的运算数量（又称复杂度）。大$O$表示法侧重于描述当数据量较大时算法的运行速度，这非常符合算法的运行工况。它的表达式关心的是函数最高的幂次（或称阶数），想一想似乎确实很有道理。看一个例子：

- 输入$N$个数，找出所有的$x$和$y$满足两数之和为$W$并输出

让我瞎搞个思路：把$\{ A \}$排序，从前往后对每个$A_i$用一次用二分查找是否存在$W-A_i$

请问复杂度是多少呢？让我们一步一步分解



1. 输入：$N$次操作

2. 排序：$N\log N$次

3. 从前往后遍历：$N$次

   每次使用二分查找：$\log N$次

   合起来：$N\log N$次

4. 输出：$N$次操作



来看这两个问题：

1. 第一步和第四步是算法的组成么？

   不是

2. 该算法的复杂度是多少？

   $Nlog N + Nlog N ~ NlogN$

   
> 请你们不要被这些表面数字所困扰住。



## 状态

什么是状态？这是一个非常模糊的问题，我们用两个同义词来稍加解释：属性，特性。

想想，生活中有哪些常见的“状态”。

- 时空位置
- 价格
- 距离
- ...

题目中经常有

- 是否选过，是否走过
- 父节点，子节点
- 左端点，右端点
- 当前的代价
- ...



那么，对于我们目前要掌握的题目，其实都可以抽象成这么一个简单的概念：

题目给定了一个初始状态，给定了一个终止状态，请找出中间的代价/最优解等等



如何解决这样的题目呢？

先找到各式各样的多种状态，然后利用你找到的这些状态组合起来，形成状态转移方程，从题目指定的状态开始一直转移到终止的状态，并检查一些题目要求维护的信息。过程中如果遇见不合法的情况，则还原到上一步。

> 是不是感觉很熟悉呢



## 递归

Recursion 递归指在一个函数中调用自己的行为。举两个简单的例子

阶乘函数：

```cpp
int fact(int n)
{
    if (n == 0) return 1;
    return n * fact(n-1);
}
```

斐波那契额函数：

```cpp
int fib(int n)
{
	if(n <= 1) return 1;
    return fib(n-1) + fib(n-2);
}
```



## DFS

Depth-First Search 深度优先搜索，从某个状态开始，不断地转移状态到题目要求的状态；或者转移到无法转移的情况，则回退到上一个状态向其他状态转移。
> 隐式的利用了函数栈作为辅助数据结构


看个几个例题感受一下

1. 部分和问题

   给定整数$a_1, a_2 \dots a_n$选取若干数，使得和为$k$

   想想有哪些状态，复杂度$O(2^N)$

   ```cpp
   bool bfs(int i, int sum)
   {
       ...
   }
   ```

2. Lake Counting(POJ.2386)

   有大小为$N \times M$的院子，雨后积了点水，八个方向连通的水被认为是一个水洼，求有多少个水洼

   样例输入：

   ```cpp
   W........WW.
   .WWW.....WWW
   ....WW...WW.
   .........WW.
   .........W..
   ..W......W..
   .W.W.....WW.
   W.W.W.....W.
   .W.W......W.
   ..W.......W.
   ```
    样例输出：
    ```cpp
    3
    ```

   代码，复杂度$O(N*M)$

   ```cpp
   char field[105][105];
   int N,M;
   void dfs(int x, int y)
   {
       //现在的位置（x,y)
       field[x][y] = '.';                          //将现在所在位置替换为'.'
       for (int dx = -1; dx <= 1; dx++)            //循环遍历连通的8个方向
       {
           for (int dy = -1; dy <= 1; dy++)
           {
               int nx = x + dx, ny = y + dy;       //向x方向移动dx,向y方向移动dy,移动的结果为(nx,ny)
               if (0 <= nx&&nx <= N && 0 <= ny&&ny <= M&&field[nx][ny] == 'W')   //判断(nx,ny)是不是在园子里，以及是否有积水
                   dfs(nx, ny);
           }
       }
   }
   int solve()
   {
      int res = 0;
       for(int i=0;i<N;i++)
           for(int j=0;j<M;j++)
               if (field[i][j] == 'W')    //从有积水的地方开始dfs
               {
                   dfs(i, j);
                   res++;
               }
       cout << res << endl;
   }
   ```



## BFS

Breadth-First Search 宽度优先搜索和DFS类似，都是为了遍历所有的状态，但是顺序和次数不同，但其实可以相互替换。

DFS的优势是可以简单的管理状态，缺点是可能重复同样的状态；BFS的优点是每个状态只经历过一次，但是比较消耗空间和你的码力。

BFS从最近的点出发，实现状态由近到远的遍历，适合处理最短路等问题。


- 看个题
   给定一个大小为N×M的迷宫。迷宫由通道和墙壁组成，每一步可以向邻接的上下左右四个的通道移动。请求出从起点到终点所需的最小步数。请注意，本题假定从起点一定可以移动到终点。（N,M≤100）（'#', '.' , 'S', 'G'分别表示墙壁、通道、起点和终点）
   
    输入
    ```cpp
    #S######.#
    ......#..#
    .#.##.##.#
    .#........
    ##.##.####
    ....#....#
    .#######.#
    ....#.....
    .####.###.
    ....#...G#
    ```
    输出
    ```cpp
    22
    ```
    代码，复杂度$O(N*M)$
    ```cpp
    const int INF = 0x3f3f3f, maxn = 105;
    // 偷懒
    typedef pair<int, int> P;
    // 存图
    char maze[maxn][maxn];
    int n, m;
    int sx, sy; //起点
    int gx, gy; //终点
    //到各个位置的最短距离的数组
    int d[maxn][maxn];    

    //4个方向移动
    int dx[4] = { 1,0,-1,0 }, dy[4]= { 0,1,0,-1 };


    //求从(sx,sy)到(gx,gy)的最短距离，若无法到达则是INF
    int bfs()
    {
        queue<P> que; 
        
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                d[i][j] = INF;  //所有的位置都初始化为INF

        // 初始化
        que.push(P(sx, sy));    //将起点加入队列中
        d[sx][sy] = 0;          //并把这一地点的距离设置为0

        while (que.size())      //不断循环直到队列的长度为0
        {
            P p = que.front();      // 从队列的最前段取出元素
            que.pop();              //取出后从队列中删除该元素

            // 到达终点
            if (p.first == gx&&p.second == gy)  break;
            //四个方向的循环
            for (int i = 0; i < 4; i++)     
            {
                int nx = p.first + dx[i],ny = p.second + dy[i];     //移动后的位置标记为(nx,ny)

                if (0 <= nx && nx < n && 0 <= ny&&ny < m && maze[nx][ny] != '#' && d[nx][ny] == INF)  //判断是否可以移动以及是否访问过(即d[nx][ny]!=INF）
                {
                    que.push(P(nx, ny));    //可以移动，添加到队列
                    d[nx][ny] = d[p.first][p.second] + 1;   //到该位置的距离为到p的距离+1
                }
            }
        }
        return d[gx][gy];
    }

    void solve()
    {
        int res = bfs();
        cout << res << endl;
    }
    ```

## 练习题

- **DFS**:

  [P1219](https://www.luogu.com.cn/blog/_post/20871)，[P1162](https://www.luogu.com.cn/blog/_post/4051)，[P1141](https://www.luogu.com.cn/blog/_post/3722)

- **BFS**:

  [P1825](https://www.luogu.com.cn/blog/_post/190015)





