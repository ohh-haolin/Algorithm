# 老生常谈

## 时间复杂度

众所周知，计算机中我们常常使用大$O$表示法来描述一个算法的运算数量（又称复杂度）。大$O$表示法侧重于描述当数据量较大时算法的运行速度，这非常符合算法的运行工况。它的表达式关心的是函数最高的幂次（或称阶数），想一想似乎确实很有道理。看一个例子：

- 输入$N$个数，找出所有的$x$和$y$满足两数之和为$W$并输出

让我瞎搞个思路：把$\{ A \}$排序，从前往后对每个$A_i$用一次用二分查找是否存在$W-A_i$

请问复杂度是多少呢？让我们一步一步分解



1. 输入：$N$次操作

2. 排序：$N\log N$次

3. 从前往后遍历：$N$次

   每次使用二分查找：$\log N$次

   合起来：$N\log N$次

4. 输出：$N$次操作



来看这些问题：

1. 第一步和第四步是算法的组成么？

   不是

2. 该算法的复杂度是多少？

   $Nlog N + Nlog N = 2NlogN$

3. 为什么要写个系数？

   尽管你的确可以不写系数，有可能有很多人吹捧，但请你思考，大$O$表示的仅仅是数字么？

   如果仅仅是$N \log N$你真的能够明白这个算法的过程和特性么？

   数据量是否真的足够大以至于你可以忽略掉这个系数了么？

   


> 请你们不要被这些表面数字所困扰住。



## 状态

什么是状态？这是一个非常模糊的问题，我们用两个同义词来稍加解释：属性，特性。

想想，生活中有哪些常见的“状态”。

- 时空位置
- 价格
- 距离
- ...

题目中经常有

- 是否选过，是否走过
- 父节点，子节点
- 左端点，右端点
- 当前的代价
- ...



那么，对于我们目前要掌握的题目，其实都可以抽象成这么一个简单的概念：

题目给定了一个初始状态，给定了一个终止状态，请找出中间的代价/最优解等等



如何解决这样的题目呢？

先找到各式各样的多种状态，然后利用你找到的这些状态组合起来，形成状态转移方程，从题目指定的状态开始一直转移到终止的状态，并检查一些题目要求维护的信息。过程中如果遇见不合法的情况，则还原到上一步。

> 是不是感觉很熟悉呢



## 递归

Recursion 递归指在一个函数中调用自己的行为。举两个简单的例子

阶乘函数：

```cpp
int fact(int n)
{
    if (n == 0) return 1;
    return n * fact(n-1);
}
```

斐波那契额函数：

```cpp
int fib(int n)
{
	if(n <= 1) return 1;
    return fib(n-1) + fib(n-2);
}
```



## DFS

Depth-First Search 深度优先搜索，从某个状态开始，不断地转移状态到题目要求的状态；或者转移到无法转移的情况，则回退到上一个状态向其他状态转移。



看个几个例题感受一下

1. 部分和问题

   给定整数$a_1, a_2 \dots a_n$选取若干数，使得和为$k$

   想想有哪些状态

   ```cpp
   bool bfs(int i, int sum)
   {
       ...
   }
   ```

2. Lake Counting(POJ.2386)

   有大小为$N \times M$的院子，雨后积了点水，八个方向连通的水被认为是一个水洼，求有多少个水洼

   样例：

   ```cpp
   W........WW.
   .WWW.....WWW
   ....WW...WW.
   .........WW.
   .........W..
   ..W......W..
   .W.W.....WW.
   W.W.W.....W.
   .W.W......W.
   ..W.......W.
   ```

   代码

   ```cpp
   #include<iostream>
   #include<algorithm>
   using namespace std;
   char field[105][105];
   int N,M;
   void dfs(int x, int y)
   {
       //现在的位置（x,y)
       field[x][y] = '.';//将现在所在位置替换为'.'
       for (int dx = -1; dx <= 1; dx++)//循环遍历连通的8个方向
       {
           for (int dy = -1; dy <= 1; dy++)
           {
               int nx = x + dx, ny = y + dy;//向x方向移动dx,向y方向移动dy,移动的结果为(nx,ny)
               if (0 <= nx&&nx <= N && 0 <= ny&&ny <= M&&field[nx][ny] == 'W')//判断(nx,ny)是不是在园子里，以及是否有积水
                   dfs(nx, ny);
           }
       }
   }
   int main()
   {
       cin >> N >> M;
       for (int i = 0; i < N; i++)
           for (int j = 0; j < M; j++)
               cin >> field[i][j];
       int res = 0;
       for(int i=0;i<N;i++)
           for(int j=0;j<M;j++)
               if (field[i][j] == 'W')//从有积水的地方开始dfs
               {
                   dfs(i, j);
                   res++;
               }
       cout << res << endl;
       return 0;
   }
   ```



## BFS



看个题：







## 练习题

- **DFS**:

  [P1219](https://www.luogu.com.cn/blog/_post/20871)，[P1162](https://www.luogu.com.cn/blog/_post/4051)，[P1141](https://www.luogu.com.cn/blog/_post/3722)

- **BFS**:

  [P1825](https://www.luogu.com.cn/blog/_post/190015)





